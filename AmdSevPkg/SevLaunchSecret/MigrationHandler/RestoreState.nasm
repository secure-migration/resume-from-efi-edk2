#include "AutoGeneratedStateOffsets.h"

%define ENABLE_DEBUG

  DEFAULT REL
  SECTION .text

;extern ASM_PFX(MyTarget)
;extern ASM_PFX(gSavedCR0)
;extern ASM_PFX(gSavedCR2)
;extern ASM_PFX(gSavedCR3)
;extern ASM_PFX(gSavedCR4)
;extern ASM_PFX(gSavedRIP)
;extern ASM_PFX(gSavedGDTDesc)
;extern ASM_PFX(gSavedContext)
extern ASM_PFX(gRelocatedRestoreRegisters)
extern ASM_PFX(gRelocatedRestoreRegistersData)
extern ASM_PFX(gTempPGT)
extern ASM_PFX(gMMUCR4Features)
extern ASM_PFX(gRelocatedRestoreStep2)

%define X86_CR4_PGE     BIT7

;
;arg 1:Char to print
;dx must be already set to the debug console port (0x402)
;
%macro DBG_PUT_CHAR   1
    mov     al, %1
    out     dx, al
%endmacro

%macro DBG_PUT_REG 1
%ifdef ENABLE_DEBUG
    mov     dx, 0x402
    DBG_PUT_CHAR 'H'
    DBG_PUT_CHAR 'E'
    DBG_PUT_CHAR 'X'
    DBG_PUT_CHAR '|'
    mov     rax, %1
    %rep 8
        out     dx, al
        shr     rax, 8
    %endrep
    DBG_PUT_CHAR '|'
    DBG_PUT_CHAR 0x0d
    DBG_PUT_CHAR 0x0a
%endif
%endmacro

%macro DBG_PUT_CHARS 1
    %strlen len %1
    %assign i 0
    %rep len
        %assign i i+1
        %substr curr_char %1 i
        DBG_PUT_CHAR curr_char
    %endrep
%endmacro

;
;arg 1: String to print (CRLF is added)
;
%macro DBG_PRINT 1
%ifdef ENABLE_DEBUG
    mov     dx, 0x402
    DBG_PUT_CHARS %1
    DBG_PUT_CHAR 0x0d
    DBG_PUT_CHAR 0x0a
%endif
%endmacro

global ASM_PFX(RestoreStep1)
ASM_PFX(RestoreStep1):

_here_rs1:
    lea     rcx, [rel _here_rs1]     ; RIP + 0
    DBG_PRINT 'DBG:RIP_RS1='
    DBG_PUT_REG rcx

    DBG_PRINT 'RSTR1:74'
    mov     r8, qword [gRelocatedRestoreRegisters]
    mov     r10, qword [gRelocatedRestoreRegistersData]
    mov     r9, qword [r10 + STATE_CR3]

    DBG_PRINT 'RSTR1:78'
    mov     r11, qword [gTempPGT]
    ;mov     rbx, qword [gMMUCR4Features]
    mov     rbx, qword [r10 + STATE_CR4]

    DBG_PRINT 'RSTR1:81'
    mov     rcx, qword [gRelocatedRestoreStep2]
    jmp     rcx

; Inputs:
;   r11 - Temporary PGD
;   rbx - Content of CR4
;   r8  - Address of target RestoreRegisters (must be mapped both
;         in temporay and target page tables)
;
; Should not modify:
;   r9 - Target CR3
;   r10 - Address of relocated CPU state structure
;
ALIGN EFI_PAGE_SIZE
global ASM_PFX(RestoreStep2)
ASM_PFX(RestoreStep2):

_here_rs2:
    lea     rcx, [rel _here_rs2]     ; RIP + 0
    DBG_PRINT 'DBG:RIP_RS2='
    DBG_PUT_REG rcx

    ; Switch to temporary PGD (from r11)
    DBG_PRINT 'RSTR2:96'
    mov     cr3, r11
    DBG_PRINT 'RSTR2:98'

    ; Turn off PGE (Page Global Enabled)
    DBG_PRINT 'RSTR2:101'
    mov     rcx, rbx
    DBG_PRINT 'RSTR2:103'
    and     rcx, ~X86_CR4_PGE
    DBG_PRINT 'RSTR2:105'
    mov     cr4, rcx
    DBG_PRINT 'RSTR2:107'

    ; Force flush TLB
    mov     rcx, cr3
    mov     cr3, rcx

    ; i think this may have been a mistake?
    ; mov     rbx, cr4

    ; Turn PGE back on
    mov     cr4, rbx

    ; Note: Not using the pbe loop from linux kernel

    ; Jump to the relocated RestoreRegisters
    jmp	r8

; Inputs:
;   r9 - Target CR3
;   r10 - Address of relocated CPU state structure
;
ALIGN EFI_PAGE_SIZE
global ASM_PFX(RestoreRegisters)
ASM_PFX(RestoreRegisters):

_here_rr:
    lea     rcx, [rel _here_rr]     ; RIP + 0
    DBG_PRINT 'DBG:RIP_RR='
    DBG_PUT_REG rcx

    DBG_PRINT 'DBG:70'
    mov     cr3, r9
    DBG_PRINT 'DBG:cr3='
    DBG_PUT_REG r9

    ;; Turn off PGE (Page Global Enabled)
    DBG_PRINT 'DBG:PGEOFF'
    mov     rcx, rbx
    and     rcx, ~X86_CR4_PGE
    DBG_PRINT 'DBG:SETCR4_A'
    mov     cr4, rcx

    ; Force flush TLB
    DBG_PRINT 'DBG:FLUSHTLB'
    mov     rcx, cr3
    mov     cr3, rcx

    ;; Turn PGE back on
    DBG_PRINT 'DBG:SETCR4_B'
    mov     cr4, rbx

    DBG_PRINT 'DBG:data r10_A='
    DBG_PUT_REG r10

    ; Currently the cpu_state is store in the next page in
    ; [rel RestoreRegisters + 0x1000]. If (in the future) we find out that
    ; we need to fit everything in one page, we can put the cpu_state in the
    ; last 1KB of this page as follows:
    ;lea      r10, [rel RestoreRegisters + 0xC00]
    ;DBG_PRINT 'DBG:data r10_B='
    ;DBG_PUT_REG r10

    DBG_PRINT 'DBG:90'
    mov     r9, qword [r10 + STATE_MAGIC]
    DBG_PRINT 'DBG:magic='
    DBG_PUT_REG r9

    DBG_PRINT 'DBG:95'
    mov     r9, cr4
    DBG_PRINT 'DBG:cr4='
    DBG_PUT_REG r9

    DBG_PRINT 'DBG:100'
    mov     r9, qword [r10 + STATE_CR3]
    DBG_PRINT 'DBG:new_cr3='
    DBG_PUT_REG r9
    DBG_PRINT 'DBG:101'
    mov     cr3, r9

    DBG_PRINT 'DBG:110'
    mov     r9, qword [r10 + STATE_CR0]
    mov     cr0, r9
    DBG_PRINT 'DBG:120'
    mov     r9, qword [r10 + STATE_CR2]
    mov     cr2, r9

    ;DBG_PRINT 'DBG:130'
    ;mov     r15, qword [r10 + STATE_CR4]
    ;mov     rdx, r15
    ;and     rdx, ~X86_CR4_PGE
    ;mov     cr4, rdx    ; turn off PGE
    ;DBG_PRINT 'DBG:140'
    ;mov     rcx, cr3    ; flush TLB
    ;mov     cr3, rcx    ; flush TLB
    ;DBG_PRINT 'DBG:150'
    ;mov     cr4, r15    ; turn PGE back on
    DBG_PRINT 'DBG:160'

    mov     r14, [r10 + STATE_REGS_IP]
    DBG_PRINT 'DBG:t.rip='
    DBG_PUT_REG r14
    mov     r15, [r14]
    DBG_PUT_REG r15

    DBG_PRINT 'DBG:170'
    mov     rax, r10

    ;DBG_PRINT 'DBG:180'
    ; Restore all registers except rax
    mov     rsp, [rax + STATE_REGS_SP]
    mov     rbp, [rax + STATE_REGS_BP]
    mov     rsi, [rax + STATE_REGS_SI]
    mov     rdi, [rax + STATE_REGS_DI]
    ;DBG_PRINT 'DBG:190'
    mov     rbx, [rax + STATE_REGS_BX]
    mov     rcx, [rax + STATE_REGS_CX]
    mov     rdx, [rax + STATE_REGS_DX]
    mov     r8,  [rax + STATE_REGS_R8]
    ;DBG_PRINT 'DBG:200'
    mov     r9,  [rax + STATE_REGS_R9]
    mov     r10, [rax + STATE_REGS_R10]
    mov     r11, [rax + STATE_REGS_R11]
    mov     r12, [rax + STATE_REGS_R12]
    ;DBG_PRINT 'DBG:210'
    mov     r13, [rax + STATE_REGS_R13]
    mov     r14, [rax + STATE_REGS_R14]
    mov     r15, [rax + STATE_REGS_R15]
    ;DBG_PRINT 'DBG:220'

    ; Restore flags
    push    qword [rax + STATE_REGS_FLAGS]
    popf

    ; TODO restore EFER

    ; Restore GDT
    ;lea     rax, [rel RestoreRegisters + 0x1000]
    lgdt    [rax + STATE_GDT_DESC]
    ;DBG_PRINT 'DBG:290'
    ; Restore IDT
    lidt    [rax + STATE_IDT]

    ;mov     r10, rax ; TODO this clobbers r10
    DBG_PRINT 'DBG:280'
    ;lea     rax, [rel RestoreRegisters + 0x1000]
    ; Restore segments
    ;DBG_PRINT 'DBG:SEG_CS'
    ;mov     ax, [r10 + STATE_REGS_CS]
    ;mov     cs, ax
    ;DBG_PRINT 'DBG:SEG_SS'
    ;mov     ax, [r10 + STATE_REGS_SS]
    ;mov     ss, ax
    ;DBG_PRINT 'DBG:SEG_DS'
    mov     ax, [rel RestoreRegisters + 0x1000 + STATE_DS]
    mov     ds, ax
    ;DBG_PRINT 'DBG:SEG_ES'
    mov     ax, [rel RestoreRegisters + 0x1000 + STATE_ES]
    mov     es, ax
    ;DBG_PRINT 'DBG:SEG_FS'
    mov     ax, [rel RestoreRegisters + 0x1000 + STATE_FS]
    mov     fs, ax
    ;DBG_PRINT 'DBG:SEG_GS'
    mov     ax, [rel RestoreRegisters + 0x1000 + STATE_GS]
    mov     gs, ax

    DBG_PRINT 'DBG:400'
    mov     rax, [rel RestoreRegisters + 0x1000 + STATE_REGS_ORIG_AX]
    lea     rsp, [rel RestoreRegisters + 0x1000 + STATE_REGS_IP]
    iretq
    ;mov     rax, [rax + STATE_REGS_IP]
    ;DBG_PRINT 'DBG:410'
    ;jmp     rax
    ;DBG_PRINT 'DBG:420'
    ;ret



  SECTION .data

global ASM_PFX(RestoreRegistersData)
ALIGN EFI_PAGE_SIZE
ASM_PFX(RestoreRegistersData):
    TIMES EFI_PAGE_SIZE DB 0

global ASM_PFX(pgd)
global ASM_PFX(pud)
global ASM_PFX(pmd)
global ASM_PFX(pte)

ALIGN EFI_PAGE_SIZE
ASM_PFX(pgd):
    TIMES EFI_PAGE_SIZE DB 0

ALIGN EFI_PAGE_SIZE
ASM_PFX(pud):
    TIMES EFI_PAGE_SIZE DB 0

ALIGN EFI_PAGE_SIZE
ASM_PFX(pmd):
    TIMES EFI_PAGE_SIZE DB 0

ALIGN EFI_PAGE_SIZE
ASM_PFX(pte):
    TIMES EFI_PAGE_SIZE DB 0
